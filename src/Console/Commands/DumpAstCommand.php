<?php
/**
 * DumpAstCommand.php
 *
 * MIT LICENSE
 *
 * LICENSE: This source file is subject to the MIT license.
 * A copy of the licenses text was distributed alongside this
 * file (usually the repository or package root). The text can also
 * be obtained through one of the following sources:
 * * http://opensource.org/licenses/MIT
 * * https://github.com/suralc/pvra/blob/master/LICENSE
 *
 * @author     suralc <thesurwaveing@gmail.com>
 * @license    http://opensource.org/licenses/MIT  MIT
 */
namespace Pvra\Console\Commands;


use PhpParser\Error;
use PhpParser\NodeTraverser;
use PhpParser\NodeVisitor\NameResolver;
use PhpParser\Parser;
use Pvra\PhpParser\Lexer\ExtendedEmulativeLexer;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;

/**
 * Class DumpAstCommand
 *
 * @package Pvra\Console\Commands
 */
class DumpAstCommand extends Command
{
    /**
     * @inheritdoc
     */
    protected function configure()
    {
        $this
            ->setName('debug:dumpAst')
            ->setDescription('Dumps the AST of a file generated by PHP-Parser to the console');

        $this
            ->addArgument('file', InputArgument::REQUIRED, 'File to dump')
            ->addOption('extensive', 'x', InputOption::VALUE_NONE, 'Use more extensive output format.')
            ->addOption('preventNameExpansion', 'p', InputOption::VALUE_NONE,
                'Prevent name expansion. May increase performance but sacrifices some functionality')
            ->addOption('xdebugMaxExtensiveDepth', 'd', InputOption::VALUE_REQUIRED,
                'Rendering depth of extensive output. Only used if xdebug is loaded', 150);
    }

    /**
     * @inheritdoc
     */
    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $file = $input->getArgument('file');

        if (!is_file($file) || !is_readable($file)) {
            $output->writeln(sprintf('<error>"%s" is not a valid file.</error>', $file));
            return 0x2;
        }

        $parser = new Parser(ExtendedEmulativeLexer::createDefaultInstance());

        try {
            $stmts = $parser->parse(file_get_contents($file));
        } catch (Error $error) {
            $output->writeln('<error>' . $error->getMessage() . ' in ' . realpath($file) . '</error>');
            return 0x2;
        }

        if ($input->getOption('preventNameExpansion') !== true) {
            $traverser = new NodeTraverser();
            $traverser->addVisitor(new NameResolver());
            $stmts = $traverser->traverse($stmts);
        }

        if ($input->getOption('extensive')) {
            if ($hasXdebug = extension_loaded('xdebug')) {
                $depth = ini_get('xdebug.var_display_max_depth');
                ini_set('xdebug.var_display_max_depth', intval($input->getOption('xdebugMaxExtensiveDepth')));
            }
            var_dump($stmts);
            if ($hasXdebug) {
                ini_set('xdebug.var_display_max_depth', $depth);
            }
        } else {
            print_r($stmts);
        }
    }
}
